import CommentNode as CN
import sqlite3 as sql
import re
import igraph as ig
import plotly.plotly as py
import plotly
import plotly.graph_objs as go
import plotly



def create_tree_from_table(table_name, sql_conn):
    """
    this function creates a tree from a table, representing a reddit post
    :param table_name: the name of the table to create a tree from
    :param sql_conn: an sqlite3 connector instance, connected to the database
    :return: the tree generated by the table
    """
    dict = {}
    table = sql_conn.execute("SELECT * FROM "+table_name)
    for row in table:
        if (row[0] == "0"):
            id = extract_id(row[2])
            date = row[3]
            root = CN.CommentNode(None, "root", "nono", 0, id,date, int(row[4]))
            dict[id] = root
        else:
            #extract parent
            #create new node:
            p_id = extract_id(row[2])
            id = extract_id(row[0])
            date = row[3]
            score = int(row[4])
            node = CN.CommentNode(p_id,row[1], root.get_subreddit(), 0,
                                  id,date, score)
            dict[node.get_id()] = node
    for key in dict:
        node = dict[key]
        if (node.get_father_id()):
            parent= dict[node.get_father_id()]
            node.update_parent_node(parent)
            parent.add_child(node)

    return root

def extract_id(full_id):
    """
    this function extracts only the id, out of the full_id given
    :param full_id: teh full id
    :return:
    """
    temp = full_id.split("_",1)
    if (len(temp) > 1):
        return re.sub("'", "", temp[1])
    else:
        return re.sub("'","",full_id)

def update_tree(root):
    """
    this function gets a tree without depth, and updates the tree. the updates includes:
    1. updating the depth of each node.
    2. updating the subtree size for each node
    :param root: the root of the tree to update
    :return:
    """
    update_helper(root,0)

def update_helper(node, depth):
    """
    this function is an aid function to update_depth
    :param node:  the current node to update
    :param depth: the current depth of the node
    :return:
    """
    node.set_depth(depth)
    if (not node.get_children()):
        node.set_subtree_size(0)

    size = 0
    for child in node.get_children():
        update_helper(child, depth+1)
        size+= child.get_subtree_size() + 1
    node.set_subtree_size(size)


def create_edges(root, num_dict):
    """
    this function creates the edges list of the tree who's root is given by root
    :param root: the root of the tree
    :param num_dict: a dictionary, mapping each node to its serial number.
    :return:
    """
    nodes  = []
    edges = []
    group = []
    labels = []
    nodes.append(root)
    counter = 0
    #bfs iteration on all nodes in order to create edges, group, labels.
    while (nodes):
        node = nodes.pop()
        group.append(node.get_depth())
        label = "depth: " + str(node.get_depth()) + ", subtree size: " +str(node.get_subtree_size()) \
                + ", rank: " + str(node.get_rank()) + ",date: " + node.get_date()
        labels.append(label)
        children = node.get_children()
        counter+= len(children)
        new_edges = [(num_dict[node.get_id()],num_dict[child.get_id()]) for child in
                     children]
        edges+=new_edges
        nodes.extend(children)
    return edges, labels,group

def get_num_dict(root):
    """
    this function creates a mapping between each node and its serial number
    :param root: the root of the tree to traverse.
    :return:
    """
    num_dict = {}
    nodes = []
    nodes.append(root)
    i = 0
    #bfs iteration on the tree.
    while(nodes):
        node = nodes.pop()
        num_dict[node.get_id()] = i
        i+=1
        nodes.extend(node.get_children())
    return num_dict

def create_trees(db_name, table_names):
    """
    this function creates all trees in the database db_name.
    :param db_name: the database name
    :param table_names: the names of each table in the database.
    :return:
    """
    trees = []
    conn = sql.connect(db_name)
    for table in table_names:
        root = create_tree_from_table(table, conn)
        update_tree(root)
        trees.append(root)

    conn.close()
    return trees


def plot_tree(root, name):
    """
    this function creates a plot (shown in a plotly account online) if the tree given in root.
    :param root: the root of the tree to plot.
    :param name: the name of the table this tree is defined by.
    :return:
    """
    num_dict = get_num_dict(root)
    Edges,labels,group = create_edges(root, num_dict)
    N = root.get_subtree_size() + 1
    G = ig.Graph(Edges, directed = True)
    layt=G.layout('kk', dim=3)
    print("N IS " +str(N))
    print("kength is " + str(len(layt)))
    if (N ==1):
        print("this is an empty graph")
        return
    Xn=[layt[k][0] for k in range(N)]# x-coordinates of nodes
    Yn=[layt[k][1] for k in range(N)]# y-coordinates
    Zn=[layt[k][2] for k in range(N)]# z-coordinates
    Xe=[]
    Ye=[]
    Ze=[]
    for e in Edges:
        Xe+=[layt[e[0]][0],layt[e[1]][0], None]# x-coordinates of edge ends
        Ye+=[layt[e[0]][1],layt[e[1]][1], None]
        Ze+=[layt[e[0]][2],layt[e[1]][2], None]

    trace1=go.Scatter3d(x=Xe,
                   y=Ye,
                   z=Ze,
                   mode='lines',
                   line=dict(color='rgb(125,125,125)', width=1),
                   hoverinfo='none'
                   )

    trace2=go.Scatter3d(x=Xn,
                   y=Yn,
                   z=Zn,
                   mode='markers',
                   name='actors',
                   marker=dict(symbol='circle',
                                 size=6,
                                 color=group,
                                 colorscale='Viridis',
                                 line=dict(color='rgb(50,50,50)', width=0.5)
                                 ),
                   text=labels,
                   hoverinfo='text'
                   )

    axis=dict(showbackground=False,
              showline=False,
              zeroline=False,
              showgrid=False,
              showticklabels=False,
              title=''
              )

    layout = go.Layout(
             title="Comment Tree for table " + name,
             width=1000,
             height=1000,
             showlegend=False,
             scene=dict(
                 xaxis=dict(axis),
                 yaxis=dict(axis),
                 zaxis=dict(axis),
            ),
     margin=dict(
        t=100
    ),
    hovermode='closest',
    annotations=[
           dict(
           showarrow=False,
            text="Data taken from reddit", #try to denote here the subreddit\url this is taken from
            xref='paper',
            yref='paper',
            x=0,
            y=0.1,
            xanchor='left',
            yanchor='bottom',
            font=dict(
            size=14
            )
            )
        ],    )

    data=[trace1, trace2]
    fig=go.Figure(data=data, layout=layout)
    plotly.offline.plot(fig, filename="trees/politics/reddit_" + name + ".html", auto_open=False)


def create_all_tree_plots(trees, table_names):
    """
    this function creates all the plots of the trees given by trees
    :param trees: all of the trees to plot
    :param table_names: the names of the tables defining the trees.
    :return:
    """
    plotly.tools.set_credentials_file(username='sweedy12', api_key="7Sg9K9AJg7kAIIaNKYvl")
    plotly.offline.init_notebook_mode(connected=True)

    for i in range(len(trees)):
        root = trees[i]
        name = table_names[i]
        plot_tree(root, name)


